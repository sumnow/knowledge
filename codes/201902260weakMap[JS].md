# weakMap

WeakMap 的 key 只能是 Object 类型. 原始数据类型 是不能作为 key 的(比如 Symbol). 

## Why WeakMap?

在 JavaScript 里, map API 可以通过使其四个 API 方法共用两个数组(一个存放键, 一个存放值)来实现. 给这种 map 设置值时会同时将键和值添加到这两个数组的末尾. 从而使得键和值的索引在两个数组中相对应. 当从该 map 取值的时候, 需要遍历所有的键, 然后使用索引从存储值的数组中检索出相应的值. 

但这样的实现会有两个很大的缺点, 首先赋值和搜索操作都是 O(n) 的时间复杂度( n 是键值对的个数), 因为这两个操作都需要遍历全部整个数组来进行匹配. 另外一个缺点是可能会导致内存泄漏, 因为数组会一直引用着每个键和值. 这种引用使得垃圾回收算法不能回收处理他们, 即使没有其他任何引用存在了. 

相比之下, 原生的 WeakMap 持有的是每个键或值对象的"弱引用", 这意味着在没有其他引用存在时垃圾回收能正确进行. 原生 WeakMap 的结构是特殊且有效的, 其用于映射的 key 只有在其没有被回收时才是有效的. 

正由于这样的弱引用, WeakMap 的 key 是不可枚举的 (没有方法能给出所有的 key). 如果key 是可枚举的话, 其列表将会受垃圾回收机制的影响, 从而得到不确定的结果. 因此, 如果你想要这种类型对象的 key 值的列表, 你应该使用 Map. 

