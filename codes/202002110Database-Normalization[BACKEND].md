<!--
Created: Mon Feb 10 2020 18:29:49 GMT+0800 (China Standard Time)
Modified: Tue Feb 11 2020 17:24:21 GMT+0800 (China Standard Time)
-->

# 数据库范式

## 基本概念

### 主键

设 K 为某表中的一个属性或属性组, 若除 K 之外的所有属性都完全函数依赖于 K(这个"完全"不要漏了), 那么我们称 K 为候选键, 简称为键. 在实际中我们通常可以理解为: 假如当 K 确定的情况下, 该表除 K 之外的所有属性的值也就随之确定, 那么 K 就是键. 一张表中可以有超过一个键.(实际应用中为了方便, 通常选择其中的一个码作为主码)

### 候选键

候选键(candidate key): 不含有多余属性的超键称为候选键. 也就是关系中的一个属性组, 其值能唯一标识一个元组. 若从属性组中去掉任何一个属性, 它就不具有这一性质了, 这样的属性组称作候选键.

主属性: 任何一个候选键中的属性称作主属性.(请记住这个概念)

## 第一范式

定义: 关系中每一分量不可再分. 即不能以集合, 序列等作为属性.(也就是不能表中套表, 要保证数据的原子性.)

例如商品表里有, 名称, 价格, 进货三个属性, 但同时进货又有进货时间和进货地两个属性, 就是不符合第一范式的.

## 第二范式

这里要举例说明, 假如有一个表

> 限定条件是每个产品只有一个进货厂商和固定的进货工厂

| 商品名称 | 进货日期 | 进货厂商 | 进货价格 | 进货省份 |
|--------|--------|--------|--------|--------|
| 车     | 02.02  | 奔驰   | 100    | 天津   |
| 车     | 02.01  | 奔驰   | 90     | 天津   |
| 枕头   | 02.03  | 席梦思  | 10     | 天津   |

键是商品名称和日期的属性组合, 那么非主键就是进货厂商, 进货价格, 进货省份

然后我们要来查看非主键是不是对主键存在部分函数依赖

先看 `(名称,日期) => (进货厂商)` , 已经有 `名称 => 进货厂商` , 所以非主键 `进货厂商` 对 `(名称,日期)` 部分函数依赖.

因为存在非主键对主键存在部分函数依赖, 所以不符合第二范式的标准

解决方案是, 将大表拆成两个

表1:

| 商品名称 | 进货厂商 | 进货省份 |
|--------|--------|--------|

表2:

| 商品名称 | 进货日期 | 进货价格 |
|--------|--------|--------|

此时就符合了第二范式

## 第三范式

第三范式解决的是非主键对于主属性的传递函数依赖

表1是不符合的, 因为 `商品名称=> 进货厂商` , `进货厂商=>进货省份` 所以进货省份对商品名称存在传递函数依赖, 解决方法是拆成两个表

表3: 

| 商品名称 | 进货厂商 |
|--------|--------|

表4:

| 进货厂商 | 进货省份 |
|--------|--------|

## BCNF

在 3NF 的基础上消除主属性对于键的部分与传递函数依赖.

## 求解3NF和BCNF

R = (ABCDEF)

f= (AE=>F, A=>B, BC=>D, CD=>A, CE=>F) 

第一步求解候选键

左边出现: CE

左右出现: ABD

右边出现: F

先查看左边出现的CE是不是候选键, 但是CE只能推出F, 且C, E均没有单推出其他.

所以从左右都出现里一个个取出

ACE 可以推出所有, 即ACE是候选键, 同理, BCE, DCE均是候选键

求解3NF, 先将f里的关系建立表, 然后查看有没有候选键表, 没有, 则任意补足一个候选键

3NF = (R(AEF), R(AB), R(BCD), R(CDA), R(CEF), R(ACE))

[link]](https://www.bilibili.com/video/av73465943?from=search&seid=10363697508647635029)

## 数据库设计范式及其意义和不足

现在大型项目倾向于反范式设计, 得益于大容量硬盘的白菜价和计算机的性能提升, 表的设计尽量冗余, 表关系尽量设置为一对一而不是一对多, 有助于大并发时的效率提升.

数据库的设计范式是数据库设计所需要满足的规范, 数据库的规范化是优化表的结构和优化把数据组织到表中的方式, 这样使数据更明确, 更简洁. 实践中, 通常把一个数据库分成两个或多个表并定义表之间的关系以做到数据隔离, 添加, 删除和修改某个字段只需要在一个表中进行, 接着可以通过定义的关系传递到数据库中剩余的表中(和分层思想的意义所在很相似). 这样我们可以消除很多错误或垃圾数据出现的机会并减轻更新信息所必要的工作量.

目前, 主要有六种范式: 第一范式, 第二范式, 第三范式, BC范式, 第四范式和第五范式. 满足最低要求的叫第一范式, 简称1NF. 在第一范式基础上进一步满足一些要求的为第二范式, 简称2NF. 其余依此类推

事物往往具有多面性, 设计范式也会带来一定的麻烦: 操作困难, 因为需要联系多个表才能得到所需要数据, 而且范式越高性能就会越差. 所以使用多高的范式需要权衡利弊, 一般在项目中, 使用到第三范式也就足够了, 性能好而且方便管理数据.

