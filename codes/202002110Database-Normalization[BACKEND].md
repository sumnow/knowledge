<!--
Created: Mon Feb 10 2020 18:29:49 GMT+0800 (China Standard Time)
Modified: Mon Feb 10 2020 19:36:56 GMT+0800 (China Standard Time)
-->

# 数据库范式

## 基本概念

### 主键

设 K 为某表中的一个属性或属性组, 若除 K 之外的所有属性都完全函数依赖于 K(这个"完全"不要漏了), 那么我们称 K 为候选键, 简称为键. 在实际中我们通常可以理解为: 假如当 K 确定的情况下, 该表除 K 之外的所有属性的值也就随之确定, 那么 K 就是键. 一张表中可以有超过一个键.(实际应用中为了方便, 通常选择其中的一个码作为主码)

### 候选键

候选键(candidate key): 不含有多余属性的超键称为候选键. 也就是关系中的一个属性组, 其值能唯一标识一个元组. 若从属性组中去掉任何一个属性, 它就不具有这一性质了, 这样的属性组称作候选键.

主属性: 任何一个候选键中的属性称作主属性.(请记住这个概念)

## 第一范式

定义: 关系中每一分量不可再分. 即不能以集合, 序列等作为属性.(也就是不能表中套表, 要保证数据的原子性.)

例如商品表里有, 名称, 价格, 进货三个属性, 但同时进货又有进货时间和进货地两个属性, 就是不符合第一范式的.

## 第二范式

这里要举例说明, 假如有一个表

> 限定条件是每个产品只有一个进货厂商和固定的进货工厂

| 商品名称 | 进货日期 | 进货厂商 | 进货价格 | 进货省份 |
|--------|--------|--------|--------|--------|
| 车     | 02.02  | 奔驰   | 100    | 天津   |
| 车     | 02.01  | 奔驰   | 90     | 天津   |
| 枕头   | 02.03  | 席梦思  | 10     | 天津   |

键是商品名称和日期的属性组合, 那么非主键就是进货厂商, 进货价格, 进货省份

然后我们要来查看非主键是不是对主键存在部分函数依赖

先看 `(名称,日期) => (进货厂商)` , 已经有 `名称 => 进货厂商` , 所以非主键 `进货厂商` 对 `(名称,日期)` 部分函数依赖.

因为存在非主键对主键存在部分函数依赖, 所以不符合第二范式的标准

解决方案是, 将大表拆成两个

表1:

| 商品名称 | 进货厂商 | 进货省份 |
|--------|--------|--------|

表2:

| 商品名称 | 进货日期 | 进货价格 |
|--------|--------|--------|

此时就符合了第二范式

## 第三范式

第三范式解决的是非主键对于主属性的传递函数依赖

表1是不符合的, 因为 `商品名称=> 进货厂商` , `进货厂商=>进货省份` 所以进货省份对商品名称存在传递函数依赖, 解决方法是拆成两个表

表3: 

| 商品名称 | 进货厂商 |
|--------|--------|

表4:

| 进货厂商 | 进货省份 |
|--------|--------|

## BCNF

在 3NF 的基础上消除主属性对于键的部分与传递函数依赖.

## 求解3NF和BCNF

R = (ABCDEF)

f= (AE=>F, A=>B, BC=>D, CD=>A, CE=>F) 

第一步求解候选键

左边出现: CE

左右出现: ABD

右边出现: F

先查看左边出现的CE是不是候选键, 但是CE只能推出F, 且C, E均没有单推出其他.

所以从左右都出现里一个个取出

ACE 可以推出所有, 即ACE是候选键, 同理, BCE, DCE均是候选键

求解3NF, 先将f里的关系建立表, 然后查看有没有候选键表, 没有, 则任意补足一个候选键

3NF = (R(AEF), R(AB), R(BCD), R(CDA), R(CEF), R(ACE))

[link]](https://www.bilibili.com/video/av73465943?from=search&seid=10363697508647635029)

