<!--
Created: Mon Aug 26 2019 15:20:58 GMT+0800 (China Standard Time)
Modified: Fri Dec 13 2019 09:48:38 GMT+0800 (China Standard Time)
-->

# 求值策略(Evaluation strategy)

## define on wiki

求值策略(英语: Evaluation strategy)是确定编程语言中表达式的求值的一组(通常确定性的)规则. 重点典型的位于函数或算子上——求值策略定义何时和以何种次序求值给函数的实际参数, 什么时候把它们代换入函数, 和代换以何种形式发生. 经常使用用来研究函数的形式系统λ演算来建模求值策略, 这里它们通常叫做*归约策略*. 求值策略分为两大基本类, 严格的和非严格的, 基于如何处理给函数的实际参数. 一个语言可以组合多种求值策略; 例如C++组合了传值调用和传引用调用. 多数语言对布尔表达式和if语句使用某种形式的非严格求值.

下面是分类, 分类不完全, 详细请查阅[wiki](https://zh.wikipedia.org/wiki/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5)

### 严格求值(Strict evaluation)

#### 传值调用(Call by value)

"传值调用"求值是最常见的求值策略, C和Scheme这样差异巨大的语言都在使用. 在传值调用中实际参数被求值, 其值被绑定到函数中对应的变量上(通常是把值复制到新内存区域). 如果函数或过程能把值赋给它的形式参数, 则被赋值的只是局部拷贝——就是说, 在函数返回后调用者作用域里的曾传给函数的任何东西都不会变.

传值调用不是一个单一的求值策略, 而是指一类函数的实参在被传给函数之前就被求值的求值策略. 尽管很多使用传值调用的编程语言(如Common Lisp, Eiffel, Java)从左至右的求值函数的实际参数, 某些语言(比如OCaml)从右至左的求值函数和它们的实际参数, 而另一些语言(比如Scheme和C)未指定这种次序(尽管它们保证顺序一致性).

#### 传引用调用(Call by reference)

在"传引用调用"求值中, 传递给函数的是它的实际参数的隐式引用而不是实参的拷贝. 通常函数能够修改这些参数(比如赋值), 而且改变对于调用者是可见的. 因此传引用调用提供了一种调用者和函数交换数据的方法. 传引用调用的语言中追踪函数调用的副作用比较难, 易产生不易察觉的bug.

很多语言支持某种形式的传引用调用, 但是很少有语言默认使用它. FORTRAN II 是一种早期的传引用调用语言. 一些语言如C++, PHP, Visual Basic . NET, C#和REALbasic默认使用传值调用, 但是提供一种传引用的特别语法.

在那些使用传值调用又不支持传引用调用的语言里, 可以用引用(引用其他对象的对象), 比如指针(表示其他对象的内存地址的对象)来模拟. C和ML就用了这种方法. 这不是一种不同的求值策略(语言本身还是传值调用). 它有时被叫做"传地址调用"(call by address). 这可能让人不易理解. 在C之类不安全的语言里会引发解引用空指针之类的错误. 但ML的引用是类型安全和内存安全的.

类似的效果可由传共享对象调用(传递一个可变对象)实现. 比如Python, Ruby.

例: C用指针模拟的传引用调用

``` C
/* C */
void modify(int p, int* q, int* r) {
    p = 27; // passed by value: only the local parameter is modified
    *q = 27; // passed by value or reference, check call site to determine which
    *r = 27; // passed by value or reference, check call site to determine which
}

int main() {
    int a = 1;
    int b = 1;
    int x = 1;
    int* c = &x;
    modify(a, &b, c); // a is passed by value, b is passed by reference by creating a pointer,
                    // c is a pointer passed by value
                    // b and x are changed
    return 0;
}
```

#### 传共享对象调用(Call by sharing)

此方式由Barbara Liskov命名, 并被Python, Java(对象类型), JavaScript, Scheme, OCaml等语言使用.

与传引用调用不同, 对于调用者而言在被调用函数里修改参数是没有影响的. 如果要达成传引用调用的效果就需要传一个共享对象, 一旦被调用者修改了对象, 调用者就可以看到变化(因为对象是共享的, 没有拷贝). 比如这段Python代码:

``` Python
# Python
def f(l):
    l.append(1)
    l = [2]
m = []
f(m)
print(m)
```

会输出[1]而不是[2]. 因为列表是可变的, append方法改变了m. 而赋值局部变量l的行为对外面作用域没有影响(在这类语言中赋值是给变量绑定一个新对象, 而不是改变对象).

使用C/C++语言的程序员可能因不能用指针等使函数返回多个值而感到不便, 但是像Python这样的语言提供了替代方案: 函数能方便的返回多个值, 比C++11的std::tie更加简单.

### 非严格求值(Non-strict evaluation)

#### 传名调用(Call by name)

在"传名调用"求值中, 根本就不求值给函数的实际参数——而是使用避免捕获代换把函数的实际参数直接代换入函数体内. 如果实际参数在函数的求值中未被用到, 则它永不被求值; 如果这个实际参数使用多次, 则它每次都被重新求值.(参见Jensen设备.)

传名调用求值超过传值调用求值的优点是传名调用求值在一个值存在的时候总是生成这个值, 而传名调用可能不终止如果这个函数的实际参数是求值这个函数所不需要的不终止计算. 反过来说, 在函数的实际参数会用到的时候传名调用就非常慢了, 这是因为实践中几乎总是要使用如thunk这样的机制.

传名调用求值很少直接实现, 但是经常用于程序和编程语言的理论性质的思考中. 带有传名调用语义的现实世界中的语言趋向使用传需求调用求值. 传名调用是ALGOL 60中的缺省求值.

#### 传需求调用(Call by need)

"传需求调用"是传名调用的记忆化版本, 如果"函数的实际参数被求值了", 这个值被存储起来已备后续使用. 在"纯"(无副作用)设置下, 这产生同传名调用一样的结果; 当函数实际参数被使用两次或更多次的时候, 传需求调用总是更快.

因为表达式的求值可能出现在计算内任意远的地方, 使用传需求调用的语言一般不支持计算效果(比如mutation)除非通过使用Monad. 这消除了其值变更先于它们的延迟求值的变量的任何未预期行为.

Haskell是最周知的使用传需求调用求值的语言.

## 惰性求值(Lazy Evaluation)

在编程语言理论中, 惰性求值(英语: Lazy Evaluation), 又译为惰性计算, 懒惰求值, 也称为传需求调用(call-by-need), 是一个计算机编程中的一个概念, 目的是要最小化计算机要做的工作. 它有两个相关而又有区别的含意, 可以表示为"延迟求值"和"最小化求值". 除可以得到性能的提升外, 惰性计算的最重要的好处是它可以构造一个无限的数据类型.

### 延迟求值

延迟求值特别用于函数式编程语言中. 在使用延迟求值的时候, 表达式不在它被绑定到变量之后就立即求值, 而是在该值被取用的时候求值, 也就是说, 语句如x:=expression; (把一个表达式的结果赋值给一个变量)明显的调用这个表达式被计算并把结果放置到x中, 但是先不管实际在x中的是什么, 直到通过后面的表达式中到x的引用而有了对它的值的需求的时候, 而后面表达式自身的求值也可以被延迟, 最终为了生成让外界看到的某个符号而计算这个快速增长的依赖树.

某些编程语言默认进行惰性求值(如Miranda和Haskell), 另一些语言提供函数或特殊语法来延迟求值(如Scheme的delay或force).

延迟求值的一个好处是能够建立可计算的无限列表而没有妨碍计算的无限循环或大小问题. 例如, 可以建立生成无限斐波那契数列表的函数(经常叫做"流"). 第n个斐波那契数的计算仅是从这个无限列表上提取出这个元素, 它只要求计算这个列表的前n个成员.

在js里, 就像 `generator` 

### 最小化求值

又被叫做短路求值(Short-circuit evaluation), 是一种逻辑运算符的求值策略. 只有当第一个运算数的值无法确定逻辑运算的结果时, 才对第二个运算数进行求值.


