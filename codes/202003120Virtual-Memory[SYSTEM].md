<!--
Created: Mon Mar 30 2020 16:11:53 GMT+0800 (China Standard Time)
Modified: Mon Mar 30 2020 16:41:39 GMT+0800 (China Standard Time)
-->

# 虚拟内存

## 什么是虚拟内存(Virtual Memory)?

很多时候我们使用点了开了很多占内存的软件, 这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存. 为什么可以这样呢? 正是因为 虚拟内存 的存在, 通过 虚拟内存 可以让程序可以拥有超过系统物理内存大小的可用内存空间. 另外, 虚拟内存为每个进程提供了一个一致的、私有的地址空间, 它让每个进程产生了一种自己在独享主存的错觉(每个进程拥有一片连续完整的内存空间). 这样会更加有效地管理内存并减少出错.

虚拟内存是计算机系统内存管理的一种技术, 我们可以手动设置自己电脑的虚拟内存. 不要单纯认为虚拟内存只是"使用硬盘空间来扩展内存"的技术. 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间, 并且 把内存扩展到硬盘空间. 推荐阅读:《虚拟内存的那点事儿》

维基百科中有几句话是这样介绍虚拟内存的.

虚拟内存 使得应用程序认为它拥有连续的可用的内存(一个连续完整的地址空间), 而实际上, 它通常是被分隔成多个物理内存碎片, 还有部分暂时存储在外部磁盘存储器上, 在需要时进行数据交换. 与没有使用虚拟内存技术的系统相比, 使用这种技术的系统使得大型程序的编写变得更容易, 对真正的物理内存(例如RAM)的使用也更有效率. 目前, 大多数操作系统都使用了虚拟内存, 如Windows家族的"虚拟内存"; Linux的"交换空间"等. From:https://zh.wikipedia.org/wiki/虚拟内存214

### CPU寻址? 虚拟地址空间? 为什么需要虚拟地址空间?

这部分内容参考了Microsoft官网的介绍, 地址:https://msdn.microsoft.com/zh-cn/library/windows/hardware/hh439648(v=vs.85).aspx26
现代处理器使用的是一种称为 虚拟寻址(Virtual Addressing) 的寻址方式. 使用虚拟寻址, CPU需要将虚拟地址翻译成物理地址, 这样才能访问到真实的物理内存. 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 内存管理单元(Memory Management Unit, MMU)的硬件. MMU 需要借助存放在内存中的页表来动态翻译虚拟地址, 该页表由操作系统管理.

### 通过虚拟地址访问内存有以下优势:

程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区.
程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区. 当物理内存的供应量变小时, 内存管理器会将物理内存页(通常大小为 4 KB)保存到磁盘文件. 数据或代码页会根据需要在物理内存与磁盘之间移动.
不同进程使用的虚拟地址彼此隔离. 一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存.

最后两个问题都是关于操作系统内存管理的, 这部分知识点理解起来还是挺简单的, 更多内容比如:"页表"、"缺页"、"页面置换算法"等等推荐阅读下面几篇文章:

## 页面置换算法的作用? 常见的页面置换算法有哪些?

这个题目经常作为笔试题出现, 网上已经给出了很不错的回答, 我这里只是总结整理了一下.
地址映射过程中, 若在页面中发现所要访问的页面不在内存中, 则产生缺页中断 . 当发生缺页中断时, 如果操作系统内存中没有空闲页面, 则操作系统 必须在内存选择一个页面将其移出内存, 以便为即将调入的页面让出空间. 而用来选择淘汰哪一页的规则叫做页面置换算法, 页面置换算法的作用是 实现虚拟存储管理.

1. OPT页面置换算法（最佳页面置换算法） ：理想情况，不可能实现，一般作为衡量其他置换算法的方法。
2. FIFO页面置换算法（先进先出页面置换算法） : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
3. LRU页面置换算法（最近未使用页面置换算法） ：LRU（Least Currently Used）算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间T，当须淘汰一个页面时，选择现有页面中其T值最大的，即最近最久未使用的页面予以淘汰。
4. LFU页面置换算法（最少使用页面排序算法） : LFU（Least Frequently Used）算法会让系统维护一个按最近一次访问时间排序的页面链表，链表首节点是最近刚刚使用过的页面，链表尾节点是最久未使用的页面。访问内存时，找到相应页面，并把它移到链表之首。缺页时，置换链表尾节点的页面。也就是说内存内使用越频繁的页面，被保留的时间也相对越长。

