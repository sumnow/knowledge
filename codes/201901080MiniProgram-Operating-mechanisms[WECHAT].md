<!--
Created: Tue Jan 08 2020 10:47:26 GMT+0800 (China Standard Time)
Modified: Sun Apr 26 2020 11:23:22 GMT+0800 (China Standard Time)
-->

# 小程序运行机制

以微信小程序为例子, 分析一下小程序的运行机制以及和浏览器的差异

## 小程序的前身

小程序出来之前, 是日益丰富的微信webview的使用, 微信发布了一个SDK, 让网页开发者可以调用一些app的原生能力, 但网页难以规范化, 且依然与原生之间有差距, 因此推出了小程序. 

## 小程序的设计思路

小程序使用的方式类似hybird开发模式, 这种方式, 既避免了重复发版(原生实现), 又避免了直接套用网页的尴尬. 灵活性和健壮性的平衡. 

## 小程序的架构

小程序出于性能的考虑, 设计了两个线程, 一个是webview视图层, 一个是App服务层, 服务层是通过JSCore这种方式调用js, 依然是使用JSBridge通信. 这里就和传统浏览器的渲染和js引擎有了差异. 

但也带来了一些问题, 例如服务层不应该读取改变渲染层的结构, 服务层只有一个JS的解释器, 并没有浏览器的对象, 因此对于window等对象的访问, 也是要禁止的. 

至此, 视图层提供了一些原生组件提高了性能, 服务层处理逻辑, 使用Bridge交互. 

## 视图更新的流程

1. Native将WXML转化为JS对象,像Dom树一样,推送给渲染层
2. 服务层在触发setState之后,将改动后的数据发送到Native层
3. Native层比对数据变动,将计算好的新Dom树推送给渲染层

## 小程序的冷启动和热启动

小程序没有重启, 只有在完全退出微信, 或者删除小程序, 或者闲置很久, 大概五分钟, 或者占用内存告警, 才会销毁小程序. 之后再启动都是冷启动. 切换之类的均是热启动

## 性能优化

小程序可以通过精简页面代码, 分包之类的方式来优化, 最主要的还是 `setState` , 不应当频繁使用, 因为每次计算js都需要与Native交互. 
