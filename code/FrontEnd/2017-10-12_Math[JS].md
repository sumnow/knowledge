# Math

程序是数学的具像化表现, 或许在代码中理解数学才会事半功倍。 

例如, 实现一个函数, 参数为N, 返回小于等于它的且是3或者5的倍数的正整数和。 

很简单:

    //O(n) = n; 
    function Add(N) {
        if (n === 4) {
            return 3
        } else {
            if (n % 5 === 0 || n % 3 === 0) {
                return Add(n) + n
            }
            return Add(n)
        }
    }
    Add(15) //3+5+9+10+12+15=60

这是一种很常见的程序员思维模式, 但是我问一个问题

求[0, 15]之间, 3, 5的整倍数, 

那么我们会这么做

15/3 = 5, 那么3的倍数就是3×(1+2+3+4+5)

15/5 = 3, 那么5的倍数就是5×(1+2+3)

再去掉公倍数3*5 = 15 的整数倍, 15/15 = 1 , 15*1 = 15

那么数学等差数列[m1, m2, ...mn]求和公式

> sum = (m1+mn)*n/2

    3×(1 + 5) * 5 / 2 + 5×(1 + 3) * 3 / 2 - 15×(1 + 1) * 1 / 2 = 60

那么, 如果作为一般式推导, 

    f(N) = (3×(1 + N / 3)× N / 3 + 5×(1 + N / 5)× N / 5 - 15×(1 + N / 15)) / 2

所以最好的函数应该是

    //O(n) = 1
    function Add(N) {
        return (3×(1 + N / 3)× N / 3 + 5×(1 + N / 5)× N / 5 - 15×(1 + N / 15)) / 2
    }
    Add(15) //60

再比如transform 属性, 本质上是matrix(矩阵)的变换。 

在平面上任意一个点和原点(0, 0)都可以用(x, y)的向量来表示, 那么让这个向量变成任意向量(X, Y)需要几个参数？ 

很简单的向量计算, 只需要像这样

    X = ax + by + c
    Y = dx + ey + f

这其实也是对应一种矩阵运算

     a, b, c x X[d, e, f] * [y] = [Y]
     0, 0, 1 1 1

> 补足 0, 0, 1 是为了保证1不变

而 matrix的6个参数, 正是矩阵里变化的(a, d, b, e, c, f)

举例, 如果不变, 那么应该是(1, 1, 0, 0, 0, 0)

要往右往下平移20, 30, 那么应该是(1, 1, 0, 0, 20, 30)

放大两倍, 那么应该是(2, 2, 0, 0, 0, 0)

而旋转n度, 应该是(cosn, -sinn, sinn, cosn, 0, 0)

> 旋转可以使用极坐标来算, 比较简单。 

